#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include "model.h"
#include "db.h"
#include "scopestack.h"
#include "repository.h"
#include "exceptions.h"
#include "context.h"
#include "notify.h"
#include "node.h"
#include "datasource.h"
#include "dm.h"
#include "properties.h"
#include "crypto.h"
#include "autoptr.h"
#include "lexer.h"
#include "expr.h"
#include "tinyxml.h"
#include "credentials.h"


extern int yyparse(void *buffer);


///////////////////////////////////////////////////////////////////////////////
// Object
///////////////////////////////////////////////////////////////////////////////


Object::Object(Model &model, int id, const char *name)
	: m_model(model), m_id(id), m_name(DUP_NULL(name)), m_ownerSet(false),
	  m_owner(NULL), m_owngrp(NULL), m_domainSet(false), m_domain(NULL),
	  m_summary(NULL), m_notes(NULL), m_vars(NULL), m_access(NULL),
	  m_cacheFQDomain(NULL)
{}


/*virtual*/ Object::~Object()
{
	SAFE_FREE(m_name);
	m_owner  = NULL;		// Don't own
	m_owngrp = NULL;		// Don't own
	m_domain = NULL;		// Don't own
	SAFE_FREE(m_summary);
	SAFE_FREE(m_notes);
	SAFE_DELETE(m_vars);
	SAFE_DELETE(m_access);
	SAFE_FREE(m_cacheFQDomain);
}


Object *Object::getOwner()
{
	if(!m_ownerSet) {
		m_ownerSet = true;
		m_model.getOwnerForObject(*this);
	}

	return m_owner ? (Object*) m_owner : (Object*) m_owngrp;
}


void Object::setOwner(User *owner)
{
	m_ownerSet = true;
	m_owner    = owner;
}


void Object::setOwner(UserGroup *owngrp)
{
	m_ownerSet = true;
	m_owngrp   = owngrp;
}


void Object::add(UserGroup *usrgrp)
{
	if(!m_access) {
		m_access = new List<UserGroup>();
	}
	m_access->add(usrgrp);
}


bool Object::hasAccess(User *user)
{
	// If user is not supplied, then we check the current user
	if(!user) {
		user = m_model.getCurrentUser();
	}
	if(!user) {
		// Failed to get current user - disallow access
		return false;
	}


	if(!m_domainSet) {
		getDomain();
	}
	if(m_domain) {
		// Is the user's domain above the level of the object we are accessing?
		Domain *userdom = user->getDomain();
		if(!userdom) {
			printf("DEBUG: user's domain NOT found - disallow access\n");
		}
		Domain *dom;
		for(dom = m_domain; dom; dom = dom->getDomain()) {
			//printf("DEBUG: Checking '%s'\n", dom->name());
			if(userdom == dom) {
				//printf("DEBUG: user's domain found\n");
				break;
			}
		}
		if(!dom) {
			printf("DEBUG: user's domain NOT a parent of object - disallow access\n");
			return false;
		}

		// Check that the parent domain allows access
		if(!m_domain->hasAccess(user)) {
			// No access to parent domain - disallow access
			return false;
		}
	}

	// Now check our ACL
	if(!m_access) {
		m_access = new List<UserGroup>();
		m_model.getAccessForObject(*this);
	}

	// If ACL is empty, then default is to allow access
	if(m_access->size() == 0) {
		return true;
	}

	List<UserGroup> *groups = user->getUserGroups();
	if(!groups) {
		return false;
	}

	ListIterator<UserGroup> iter(*groups);
	for(UserGroup *grp = iter.first(); grp; grp = iter.next()) {
		ListIterator<UserGroup> acit(*m_access);
		for(UserGroup *acgrp = acit.first(); acgrp; acgrp = acit.next()) {
			if(grp->id() == acgrp->id()) {
				// ACL contains a group that the user is a member of
				return true;
			}
		}
	}

	return false;
}


Domain *Object::getDomain()
{
	if(!m_domainSet) {
		m_domainSet = true;
		m_model.getDomainForObject(*this);
	}
	return m_domain;
}


void Object::setDomain(Domain *domain)
{
	m_domainSet = true;
	m_domain    = domain;
}


const char *Object::getFQDomain()
{
	if(m_cacheFQDomain) {
		return m_cacheFQDomain;
	}

	Domain *domain = getDomain();
	if(!domain) {
		return NULL;
	}

	const char *mydom = domain->name();
	const char *fqdom = domain->getFQDomain();

	if(!fqdom) {
		m_cacheFQDomain = strdup(mydom);
	} else {
		m_cacheFQDomain = (char*) malloc(strlen(fqdom) + strlen(mydom) + 2);
		sprintf(m_cacheFQDomain, "%s.%s", fqdom, mydom);
	}

	return m_cacheFQDomain;
}


const char *Object::getSummary()
{
	if(m_summary) {
		return m_summary;
	}
	m_model.getSummaryForObject(*this);
	return m_summary;
}


void Object::setSummary(const char *summary)
{
	SAFE_FREE(m_summary);
	m_summary = strdup(summary ? summary : "");
}


const char *Object::getNotes()
{
	if(m_notes) {
		return m_notes;
	}
	m_model.getNotesForObject(*this);
	return m_notes;
}


void Object::setNotes(const char *notes)
{
	SAFE_FREE(m_notes);
	m_notes = strdup(notes ? notes : "");
}


void Object::indent(int indent)
{
	for(int n = 0; n < indent; n++) {
		printf("  ");
	}
}


void Object::printObject(int ind)
{
	if(m_access) {
		indent(ind); printf("Access: ");
		ListIterator<UserGroup> iter(*m_access);
		bool first = true;
		for(UserGroup *g = iter.first(); g; g = iter.next()) {
			printf("%s%s", (first ? "" : ", "), g->name());
			first = false;
		}
		printf("\n");
	}
	if(m_ownerSet) {
		indent(ind);
		if(m_owner) {
			printf("Owner:\n");
			m_owner->print(ind+1);
		} else if(m_owngrp) {
			printf("Owner:\n");
			m_owngrp->print(ind+1);
		} else {
			printf("Owner: (no owner)\n");
		}
	}
}


/*virtual*/ const char *Object::getAttribute(const char *name, class Context &ctx)
{
	if(strcmp(name, "name") == 0) {
		return m_name;
	}
	if(strcmp(name, "domain") == 0) {
		return getFQDomain();
	}
	if(strcmp(name, "summary") == 0) {
		return getSummary();
	}
	return NULL;
}


/*virtual*/ class DMArray *Object::getArrayAttribute(const char *name, class Context &ctx)
{
	return NULL;
}


/*virtual*/ IObject *Object::getObjectAttribute(const char *name, class Context &ctx)
{
	if(strcmp(name, "owner") == 0) {
		return getOwner();
	}
	if(strcmp(name, "parent") == 0) {
		return getDomain();
	}
	return NULL;
}


/*virtual*/ Scope *Object::getVars()
{
	return NULL;
}


///////////////////////////////////////////////////////////////////////////////
// ProviderObject
///////////////////////////////////////////////////////////////////////////////

ProviderObject::ProviderObject(
		class Model &model, int id, const char *name, const char *type
	)
	: Object(model, id, name), m_type(DUP_NULL(type)), m_credentials(NULL),
	  m_props(NULL), m_def(NULL)
{}


/*virtual*/ ProviderObject::~ProviderObject()
{
	SAFE_FREE(m_type);
	SAFE_DELETE(m_props);
	m_credentials = NULL;	// Owned by cache
	m_def = NULL;			// Owned by cache
}


/*virtual*/ const char *ProviderObject::getAttribute(const char *name, class Context &ctx)
{
	if(strcmp(name, "type") == 0) {
		return m_type;
	}

	const char *ret = Object::getAttribute(name, ctx);
	if(!ret) {
		Property *prop = getProperty(name);
		ret = prop ? prop->value() : NULL;
	}

	return ret;
}


Credentials *ProviderObject::getCredentials()
{
	if(!m_credentials) {
		m_model.getCredentialsForProviderObject(*this);
	}

	return m_credentials;
}


void ProviderObject::setCredentials(Credentials *creds)
{
	m_credentials = creds;
}


ProviderObjectDef &ProviderObject::getDef(Context &ctx)
{
	if(!m_def) {
		m_def = m_model.getDefForProviderObject(*this);
	}
	if(!m_def) {
		throw RuntimeError(ctx.stack(), "No definition for %s type '%s'", def_kind(), m_type);
	}

	return *m_def;
}


Property *ProviderObject::getProperty(const char *name)
{
	return m_props ? m_props->get(name) : NULL;
}


void ProviderObject::setProperty(Property *prop)
{
	if(!m_props) {
		m_props = new Hashtable<Property>(false, true);
	}
	m_props->put(prop->name(), prop);
}


void ProviderObject::printProviderObject(int ind)
{
	indent(ind); printf("Type: %s\n", m_type);
	printObject(ind);
	if(m_props) {
		indent(ind); printf("Properties:\n");
		AutoPtr<StringList> keys = m_props->keys();
		StringListIterator iter(*keys);
		for(const char *name = iter.first(); name; name = iter.next()) {
			Property *prop =  m_props->get(name);
			indent(ind+1); printf("%s: %s\n", name, (prop ? prop->value() : "(null)"));
		}
	}
}


///////////////////////////////////////////////////////////////////////////////
// ProviderObjectDef
///////////////////////////////////////////////////////////////////////////////

ProviderObjectDef::ProviderObjectDef(
		int id, const char *name, const char *kind, Plugin *plugin
	)
	: m_id(id), m_name(DUP_NULL(name)), m_plugin(plugin),
	  m_kind(DUP_NULL(kind)), m_propdefs(NULL), m_checker(NULL)
{}


ProviderObjectDef::~ProviderObjectDef()
{
	SAFE_FREE(m_name);
	SAFE_FREE(m_kind);
	SAFE_DELETE(m_propdefs);
	SAFE_DELETE(m_checker);
	m_plugin = NULL;	// Owned by cache
}


List<PropertyDef> *ProviderObjectDef::getPropertyDefs()
{
	if(!m_propdefs) {
		m_propdefs = new List<PropertyDef>(true);
		//	m_model.getProperyDefsForProviderObject(*this); - might do it this way at some point
	}
	return m_propdefs;
}


void ProviderObjectDef::add(class PropertyDef *propdef)
{
	if(!m_propdefs) {
		m_propdefs = new List<PropertyDef>(true);
	}
	m_propdefs->add(propdef);
}


Plugin *ProviderObjectDef::getPlugin()
{
	// might do lazy load at some point
	//if(!m_plugin) {
	//	m_model.getPluginForProviderObjectDef(*this);
	//}
	return m_plugin;
}


void ProviderObjectDef::createChecker()
{
	char *temp = (char*) malloc(strlen(m_name) + strlen(m_kind) + 2);
	sprintf(temp, "%s %s", m_name, m_kind);
	m_checker = new PropertyChecker(m_propdefs, temp);
	free(temp);
}


void ProviderObjectDef::verifyProperties(class Context &ctx, Hashtable<class Property> *props)
{
	if(!m_checker) {
		createChecker();
	}
	m_checker->checkProps(ctx, props);
}

void ProviderObjectDef::verifyArgs(class Context &ctx, class StmtList *args, Hashtable<class Property> *props)
{
	if(!m_checker) {
		createChecker();
	}
	m_checker->checkArgs(ctx, args, props);
}


///////////////////////////////////////////////////////////////////////////////
// Credentials
///////////////////////////////////////////////////////////////////////////////

Credentials::Credentials(CREDENTIALS_KIND kind)
	: m_id(0), m_name(NULL), m_kind(kind), m_encusername(NULL),
	  m_encpassword(NULL), m_filename(NULL), m_impls(NULL)
{}


Credentials::Credentials(
		int id, const char *name, CREDENTIALS_KIND kind,
		const char *encusername, const char *encpassword
	)
	: m_id(id), m_name(DUP_NULL(name)), m_kind(kind),
	  m_encusername(DUP_NULL(encusername)), m_encpassword(DUP_NULL(encpassword)),
	  m_filename(NULL), m_impls(NULL)
{}


Credentials::Credentials(
		int id, const char *name, CREDENTIALS_KIND kind, const char *filename
	)
	: m_id(id), m_name(DUP_NULL(name)), m_kind(kind), m_encusername(NULL),
	  m_encpassword(NULL), m_filename(DUP_NULL(filename)), m_impls(NULL)
{}


Credentials::Credentials(Property *username, Property *password)
	: m_id(0), m_name(strdup("From Properties")), m_kind(CREDENTIALS_ENCRYPTED),
	  m_encusername(NULL), m_encpassword(NULL), m_filename(NULL), m_impls(NULL)
{
	if(username) {
		if(username->m_encrypted) {
			m_encusername = strdup(username->m_value);
		} else {
			m_encusername = encryptValue(username->m_value, strlen(username->m_value));
		}
	}
	if(password) {
		if(password->m_encrypted) {
			m_encpassword = strdup(password->m_value);
		} else {
			m_encpassword = encryptValue(password->m_value, strlen(password->m_value));
		}
	}
}


Credentials::~Credentials()
{
	SAFE_FREE(m_name);
	SAFE_FREE(m_encusername);
	SAFE_FREE(m_encpassword);
	SAFE_FREE(m_filename);
	SAFE_DELETE(m_impls);
}


char *Credentials::internalDecryptValue(const char *value, class Object &auth, Context &ctx)
{
	if(!auth.hasAccess(NULL)) {
		throw PermissionDeniedException(ctx.stack(), "You do not have permisson to credentials");
	}

	if(!value) {
		throw RuntimeError(ctx.stack(), "Credentials value was not set - unable to decrypt");
	}

	return decryptValue(value, strlen(value));
}


char *Credentials::getDecryptedUsername(class Object &auth, class Context &ctx)
{
	switch(m_kind) {
	case CREDENTIALS_ENCRYPTED:
	case CREDENTIALS_IN_DATABASE:
		return internalDecryptValue(m_encusername, auth, ctx);
	case CREDENTIALS_FROM_VARS: {
		Node uservar(NODE_STR, strdup(m_encusername), true);
		ExprPtr euser = uservar.evaluate(ctx);
		return (euser ? euser->toString() : NULL);
		}
	}

	return NULL;
}


char *Credentials::getDecryptedPassword(class Object &auth, class Context &ctx)
{
	switch(m_kind) {
	case CREDENTIALS_ENCRYPTED:
	case CREDENTIALS_IN_DATABASE:
		return internalDecryptValue(m_encpassword, auth, ctx);
	case CREDENTIALS_FROM_VARS: {
		Node passvar(NODE_STR, strdup(m_encpassword), true);
		ExprPtr epass = passvar.evaluate(ctx);
		return (epass ? epass->toString() : NULL);
		}
	}

	return NULL;
}


bool Credentials::hasUsername()
{
	switch(m_kind) {
	case CREDENTIALS_ENCRYPTED:
	case CREDENTIALS_IN_DATABASE:
	case CREDENTIALS_FROM_VARS:
		return (m_encusername ? true : false);
	case CREDENTIALS_RTI3_DFO_IN_FILESYSTEM:
	case CREDENTIALS_HARVEST_DFO_IN_FILESYSTEM:
		return true;
	default:
		return false;
	}
}


bool Credentials::hasPassword()
{
	switch(m_kind) {
	case CREDENTIALS_ENCRYPTED:
	case CREDENTIALS_IN_DATABASE:
	case CREDENTIALS_FROM_VARS:
		return (m_encpassword ? true : false);
	case CREDENTIALS_RTI3_DFO_IN_FILESYSTEM:
	case CREDENTIALS_HARVEST_DFO_IN_FILESYSTEM:
		return true;
	default:
		return false;
	}
}


CredentialsProvider *Credentials::createImpl(const char *provider, Context &ctx)
{
	CredentialsProviderFactory *factory =
		CredentialsProviderRegistry::instance().getFactory(provider);

	if(!factory) {
		throw RuntimeError(ctx.stack(), "Unrecognised credentials provider type '%s'", provider);
	}

	// Create an instance of the impl so that we may later execute it
	CredentialsProvider *impl = factory->create(*this);
	if(!impl) {
		throw RuntimeError(ctx.stack(), "Unexpected error creating instance of credentials provider type '%s'", provider);
	}

	if(!m_impls) {
		m_impls = new Hashtable<CredentialsProvider>(false, true);
	}
	m_impls->put(provider, impl);
	return impl;
}


bool Credentials::canTransform(const char *provider, Context &ctx)
{
	CredentialsProvider *impl = m_impls ? m_impls->get(provider) : NULL;
	if(!impl) {
		impl = createImpl(provider, ctx);
	}

	return impl->canTransform();
}


const char *Credentials::transform(const char *provider, Object &auth, Context &ctx)
{
	CredentialsProvider *impl = m_impls ? m_impls->get(provider) : NULL;
	if(!impl) {
		impl = createImpl(provider, ctx);
	}

	return impl->transform(auth, ctx);
}


void Credentials::print(int indent)
{
	switch(m_kind) {
	case CREDENTIALS_USE_DIALOG:				printf("Use dialog"); break;
	case CREDENTIALS_ENCRYPTED:					printf("Encrypted"); break;
	case CREDENTIALS_IN_DATABASE:				printf("In database"); break;
	case CREDENTIALS_RTI3_DFO_IN_FILESYSTEM:	printf("RTI DFO"); break;
	case CREDENTIALS_HARVEST_DFO_IN_FILESYSTEM: printf("Harvest DFO"); break;
	default: printf("Unknown"); break;
	}
}


///////////////////////////////////////////////////////////////////////////////
// Environment
///////////////////////////////////////////////////////////////////////////////


Environment::Environment(
		Model &model, int id, const char *name, const char *basedir
	)
	: Object(model, id, name), m_basedir(DUP_NULL(basedir)), m_servers(NULL),
	  m_apps(NULL), /*m_domain(NULL), m_domainSet(false),*/
	  m_serversArrayCache(NULL), m_credentials(NULL)	  
{}


Environment::~Environment()
{
	SAFE_FREE(m_basedir);
	SAFE_DELETE(m_servers);
	SAFE_DELETE(m_apps);
	//m_domain = NULL;		// Owned by cache
	m_credentials = NULL;	// Owned by cache
	SAFE_DELETE(m_serversArrayCache);
}


const char *Environment::getAttribute(const char *name, class Context &ctx)
{
	if(strcmp(name, "basedir") == 0) {
		return m_basedir;
	}
	if(strcmp(name, "notes") == 0) {
		return getNotes();
	}
	return Object::getAttribute(name, ctx);
}


DMArray *Environment::getArrayAttribute(const char *name, class Context &ctx)
{
	if((strcmp(name, "servers") == 0) || (strcmp(name, "physicals") == 0)) {
		if(m_serversArrayCache) {
			return m_serversArrayCache;
		}
		DMArray *ret = new DMArray(false, true);
		ret->addRef();	// This prevents the array being deleted
		List<Server> *list = getServers();
		ListIterator<Server> iter(*list);
		for(Server *s = iter.first(); s; s = iter.next()) {
			ret->put(s->name(), new Variable(NULL, s));
		}
		m_serversArrayCache = ret;
		return ret;
	}
	return NULL;
}


IObject *Environment::getObjectAttribute(const char *name, class Context &ctx)
{
	if(strcmp(name, "parent") == 0) {
		return getDomain();
	}
	return Object::getObjectAttribute(name, ctx);
}


Scope *Environment::getVars()
{
	if(!m_vars) {
		m_vars = new Scope(ENVIRONMENT_SCOPE, this);
		m_model.getVariablesForObject(*this, *m_vars);
	}

	return m_vars;
}


//Domain *Environment::getDomain()
//{
//	if(!m_domainSet) {
//		m_domainSet = true;
//		m_model.getDomainForEnvironment(*this);
//	}
//	return m_domain;
//}


//void Environment::setDomain(Domain *domain)
//{
//	m_domainSet = true;
//	m_domain    = domain;
//}


List<Server> *Environment::getServers()
{
	if(!m_servers) {
		m_servers = new List<Server>();
		m_model.getServersForEnvironment(*this);
	}

	return m_servers;
}


List<Application> *Environment::getApplications()
{
	if(!m_apps) {
		m_apps = new List<Application>();
		m_model.getApplicationsForEnvironment(*this);
	}

	return m_apps;
}


Credentials *Environment::getCredentials()
{
	if(!m_credentials) {
		m_model.getCredentialsForEnvironment(*this);
	}

	return m_credentials;
}


void Environment::setCredentials(Credentials *creds)
{
	m_credentials = creds;
}


void Environment::add(Server *server)
{
	if(!m_servers) {
		m_servers = new List<Server>();
	}
	m_servers->add(server);
}


void Environment::add(Application *app)
{
	if(!m_apps) {
		m_apps = new List<Application>(true);	// TODO: This should not own the applications
	}
	m_apps->add(app);
}


bool Environment::hasAccess(User *user)
{
	// Check that the parent domain allows access first
	if(!m_domainSet) {
		getDomain();
	}
	if(m_domain) {
		if(!m_domain->hasAccess(user)) {
			// No access to domain - disallow access
			return false;
		}
	}

	return Object::hasAccess(user);
}


Server *Environment::server(const char *name)
{
	if(!m_servers) { getServers(); }
	ListIterator<Server> iter(*m_servers);
	for(Server *s = iter.first(); s; s = iter.next()) {
		if(strcmp(s->name(), name) == 0) {
			return s;
		}
	}
	return NULL;
}


class Application *Environment::application(const char *name)
{
	if(!m_apps) { getApplications(); }
	ListIterator<Application> iter(*m_apps);
	for(Application *a = iter.first(); a; a = iter.next()) {
		if(strcmp(a->name(), name) == 0) {
			return a;
		}
	}
	return NULL;
}


void Environment::print(int ind)
{
	indent(ind);   printf("Environment: %s\n", m_name);
	indent(ind+1); printf("Credentials: ");
	if(m_credentials) {
		m_credentials->print(0);
	} else {
		printf("(none)");
	}
	printf("\n");
	printObject(ind+1);
	if(m_servers) {
		//m_servers->print(ind+1);
		ListIterator<Server> iter(*m_servers);
		for(Server *s = iter.first(); s; s = iter.next()) {
			s->print(ind+1);
		}
	}
	if(m_apps) {
		//m_apps->print(ind+1);
		ListIterator<Application> iter(*m_apps);
		for(Application *a = iter.first(); a; a = iter.next()) {
			a->print(ind+1);
		}
	}
}


///////////////////////////////////////////////////////////////////////////////
// Domain
///////////////////////////////////////////////////////////////////////////////

Domain::Domain(Model &model, int id, const char *name)
	: Object(model, id, name), m_doms(NULL), m_envs(NULL), m_apps(NULL),
	  m_reps(NULL), m_nfys(NULL), m_dats(NULL)
{}


Domain::~Domain()
{
	SAFE_DELETE(m_doms);
	SAFE_DELETE(m_envs);
	SAFE_DELETE(m_apps);
	SAFE_DELETE(m_reps);
	SAFE_DELETE(m_nfys);
	SAFE_DELETE(m_dats);
}


List<Domain> *Domain::getSubdomains()
{
	if(!m_doms) {
		m_doms = new List<Domain>();
		m_model.getSubdomainsForDomain(this);
	}

	return m_doms;
}


List<Environment> *Domain::getEnvironments()
{
	if(!m_envs) {
		m_envs = new List<Environment>();
		m_model.getEnvironmentsForDomain(this);
	}

	return m_envs;
}


List<Application> *Domain::getApplications()
{
	if(!m_apps) {
		m_apps = new List<Application>();
		m_model.getApplicationsForDomain(this);
	}

	return m_apps;
}


List<Repository> *Domain::getRepositories()
{
	if(!m_reps) {
		m_reps = new List<Repository>();
		m_model.getRepositoriesForDomain(this);
	}

	return m_reps;
}


List<Notify> *Domain::getNotifys()
{
	if(!m_nfys) {
		m_nfys = new List<Notify>();
		m_model.getNotifysForDomain(this);
	}

	return m_nfys;
}


List<Datasource> *Domain::getDatasources()
{
	if(!m_dats) {
		m_dats = new List<Datasource>();
		m_model.getDatasourcesForDomain(this);
	}

	return m_dats;
}


void Domain::add(Domain *domain)
{
	if(!m_doms) {
		m_doms = new List<Domain>();
	}
	m_doms->add(domain);
}


void Domain::add(Environment *env)
{
	if(!m_envs) {
		m_envs = new List<Environment>();
	}
	m_envs->add(env);
}


void Domain::add(Application *app)
{
	if(!m_apps) {
		m_apps = new List<Application>();
	}
	m_apps->add(app);
}


void Domain::add(Repository *rep)
{
	if(!m_reps) {
		m_reps = new List<Repository>();
	}
	m_reps->add(rep);
}


void Domain::add(Notify *nfy)
{
	if(!m_nfys) {
		m_nfys = new List<Notify>();
	}
	m_nfys->add(nfy);
}


void Domain::add(Datasource *dat)
{
	if(!m_dats) {
		m_dats = new List<Datasource>();
	}
	m_dats->add(dat);
}


void Domain::print(int ind)
{
	indent(ind); printf("Domain: %s\n", m_name);
	Object::printObject(ind+1);
	if(m_doms) {
		//m_domains->print(ind+1);
		ListIterator<Domain> iter(*m_doms);
		for(Domain *d = iter.first(); d; d = iter.next()) {
			d->print(ind+1);
		}
	}
	if(m_envs) {
		//m_envs->print(ind+1);
		ListIterator<Environment> iter(*m_envs);
		for(Environment *e = iter.first(); e; e = iter.next()) {
			e->print(ind+1);
		}
	}
	if(m_apps) {
		//m_apps->print(ind+1);
		ListIterator<Application> iter(*m_apps);
		for(Application *a = iter.first(); a; a = iter.next()) {
			a->print(ind+1);
		}
	}
	if(m_reps) {
		//m_reps->print(ind+1);
		ListIterator<Repository> iter(*m_reps);
		for(Repository *r = iter.first(); r; r = iter.next()) {
			r->print(ind+1);
		}
	}
	if(m_nfys) {
		//m_nfys->print(ind+1);
		ListIterator<Notify> iter(*m_nfys);
		for(Notify *n = iter.first(); n; n = iter.next()) {
			n->print(ind+1);
		}
	}
	if(m_dats) {
		//m_dats->print(ind+1);
		ListIterator<Datasource> iter(*m_dats);
		for(Datasource *d = iter.first(); d; d = iter.next()) {
			d->print(ind+1);
		}
	}
}


///////////////////////////////////////////////////////////////////////////////
// Server
///////////////////////////////////////////////////////////////////////////////

Server::Server(
		Model &model, int id, const char *name, const char *hostname,
		const char *protocol, const char *basedir, const char *hosttype,
		LINE_END_FORMAT lineends)
	: Object(model, id, name), m_hostname(DUP_NULL(hostname)),
	  m_protocol(DUP_NULL(protocol)), m_basedir(DUP_NULL(basedir)),
	  m_credentials(NULL), m_hosttype(DUP_NULL(hosttype)),
	  m_lineends(lineends)
{}


Server::~Server()
{
	SAFE_FREE(m_hostname);
	SAFE_FREE(m_protocol);
	SAFE_FREE(m_basedir);
	m_credentials = NULL;		// Owned by cache
	SAFE_FREE(m_hosttype);
}


/*virtual*/ const char *Server::hostname()
{
	return m_hostname ? m_hostname : m_name;
}



/*virtual*/ const char *Server::getAttribute(const char *name, class Context &ctx)
{
	if(strcmp(name, "hostname") == 0) {
		return hostname();
	}
	if(strcmp(name, "basedir") == 0) {
		return m_basedir;
	}
	if(strcmp(name, "type") == 0) {
		return m_hosttype;
	}
	if(strcmp(name, "notes") == 0) {
		return getNotes();
	}
	return Object::getAttribute(name, ctx);
}


IObject *Server::getObjectAttribute(const char *name, class Context &ctx)
{
	return Object::getObjectAttribute(name, ctx);
}


Scope *Server::getVars()
{
	if(!m_vars) {
		m_vars = new Scope(SERVER_SCOPE, this);
		m_model.getVariablesForObject(*this, *m_vars);
	}

	return m_vars;
}


Credentials *Server::getCredentials()
{
	if(!m_credentials) {
		m_model.getCredentialsForServer(*this);
	}

	return m_credentials;
}


void Server::setCredentials(Credentials *creds)
{
	m_credentials = creds;
}


void Server::print(int ind)
{
	indent(ind);   printf("Server: %s\n", m_name);
	indent(ind+1); printf("Hostname: %s\n", (m_hostname ? m_hostname : "(no hostname)"));
	indent(ind+1); printf("Credentials: ");
	if(m_credentials) {
		m_credentials->print(0);
	} else {
		printf("(none)");
	}
	printf("\n");
	printObject(ind+1);
}


///////////////////////////////////////////////////////////////////////////////
// Application
///////////////////////////////////////////////////////////////////////////////


Application::Application(Model &model, int id, const char *name)
	: Object(model, id, name), m_action(NULL)
{}


Application::~Application()
{
	m_action = NULL;		// Owned by cache
}


/*virtual*/ const char *Application::getAttribute(const char *name, class Context &ctx)
{
	return Object::getAttribute(name, ctx);
}


IObject *Application::getObjectAttribute(const char *name, class Context &ctx)
{
	return Object::getObjectAttribute(name, ctx);
}


Scope *Application::getVars()
{
	if(!m_vars) {
		m_vars = new Scope(APPLICATION_SCOPE, this);
		m_model.getVariablesForObject(*this, *m_vars);
	}

	return m_vars;
}


Action *Application::getAction()
{
	if(!m_action) {
		m_model.getActionForApplication(*this);
	}
	return m_action;
}


/*private*/ void Application::setAction(Action *action)
{
	m_action = action;
}


bool Application::hasAccess(User *user)
{
	return Object::hasAccess(user);
}


void Application::print(int ind)
{
	indent(ind); printf("Application: %s\n", m_name);
	printObject(ind+1);
}



///////////////////////////////////////////////////////////////////////////////
// User
///////////////////////////////////////////////////////////////////////////////

User::User(
		Model &model, int id, const char *name, const char *email,
		const char *realname, const char *phone
	)
	: Object(model, id, name), m_email(DUP_NULL(email)),
	  m_realname(DUP_NULL(realname)), m_phone(DUP_NULL(phone)),
	  m_groups(NULL), m_groupsArrayCache(NULL),
	  m_accessibleDomainsCache(NULL)
{}


User::~User()
{
	SAFE_FREE(m_email);
	SAFE_FREE(m_realname);
	SAFE_FREE(m_phone);
	SAFE_DELETE(m_groups);
	SAFE_DELETE(m_groupsArrayCache);
	SAFE_FREE(m_accessibleDomainsCache)
}


/*virtual*/ const char *User::getAttribute(const char *name, class Context &ctx)
{
	if(strcmp(name, "email") == 0) {
		return m_email;
	}
	if(strcmp(name, "realname") == 0) {
		return m_realname;
	}
	if(strcmp(name, "phone") == 0) {
		return m_phone;
	}
	return Object::getAttribute(name, ctx);
}


DMArray *User::getArrayAttribute(const char *name, class Context &ctx)
{
	if(strcmp(name, "groups") == 0) {
		if(!m_groupsArrayCache) {
			if(!m_groups) {
				getUserGroups();
			}
			DMArray *ret = new DMArray(false, true);
			ret->addRef();	// This prevents the array being deleted
			if(m_groups) {
				ListIterator<UserGroup> iter(*m_groups);
				for(UserGroup *group = iter.first(); group; group = iter.next()) {
					ret->put(group->name(), new Variable(NULL, group));
				}
			}
			m_groupsArrayCache = ret;
		}
		return m_groupsArrayCache;
	}
	return Object::getArrayAttribute(name, ctx);
}


List<UserGroup> *User::getUserGroups()
{
	if(!m_groups) {
		m_model.getUserGroupsForUser(*this);
	}
	return m_groups;
}


void User::add(class UserGroup *group)
{
	if(!m_groups) {
		m_groups = new List<UserGroup>();
	}
	m_groups->add(group);
}


bool User::validateHashedPassword(const char *passhash)
{
	return m_model.validateHashedPassword(*this, passhash);
}


const char *User::getAccessibleDomains()
{
	if(m_accessibleDomainsCache) {
		return m_accessibleDomainsCache;
	}

	Domain *domain = getDomain();
	if(domain) {
		m_accessibleDomainsCache = m_model.getAccessibleDomains(*domain);
	}

	return m_accessibleDomainsCache;
}


void User::print(int ind)
{
	indent(ind);   printf("User: %s\n", m_name);
	indent(ind+1); printf("Email: %s\n", (m_email ? m_email : "(no email)"));
}


///////////////////////////////////////////////////////////////////////////////
// UserGroup
///////////////////////////////////////////////////////////////////////////////

UserGroup::UserGroup(
		class Model &model, int id, const char *name, const char *email
	)
	: Object(model, id, name), m_email(DUP_NULL(email)), m_users(NULL),
	  m_usersArrayCache(NULL)
{}


UserGroup::~UserGroup()
{
	SAFE_FREE(m_email);
	SAFE_DELETE(m_users);
	SAFE_DELETE(m_usersArrayCache);
}


const char *UserGroup::getAttribute(const char *name, class Context &ctx)
{
	if(strcmp(name, "email") == 0) {
		return m_email;
	}
	return Object::getAttribute(name, ctx);
}


DMArray *UserGroup::getArrayAttribute(const char *name, class Context &ctx)
{
	if(strcmp(name, "users") == 0) {
		if(!m_usersArrayCache) {
			if(!m_users) {
				getUsers();
			}
			DMArray *ret = new DMArray(false, true);
			ret->addRef();	// This prevents the array being deleted
			if(m_users) {
				ListIterator<User> iter(*m_users);
				for(User *user = iter.first(); user; user = iter.next()) {
					ret->put(user->name(), new Variable(NULL, user));
				}
			}
			m_usersArrayCache = ret;
		}
		return m_usersArrayCache;
	}
	return Object::getArrayAttribute(name, ctx);
}


List<User> *UserGroup::getUsers()
{
	if(!m_users) {
		m_model.getUsersForUserGroup(*this);
	}
	return m_users;
}


void UserGroup::add(User *user)
{
	if(!m_users) {
		m_users = new List<User>();
	}
	m_users->add(user);
}


void UserGroup::print(int ind)
{
	indent(ind);   printf("UserGroup: %s\n", m_name);
	indent(ind+1); printf("Email: %s\n", (m_email ? m_email : "(no email)"));
}


///////////////////////////////////////////////////////////////////////////////
// Repository
///////////////////////////////////////////////////////////////////////////////

Repository::Repository(class Model &model, int id, const char *name, const char *type)
	: ProviderObject(model, id, name, type),
	  m_impl(NULL), m_files(NULL), m_folders(NULL), m_infos(NULL)
{}


Repository::~Repository()
{
	SAFE_DELETE(m_impl);
	SAFE_DELETE(m_files);
	SAFE_DELETE(m_folders);
	SAFE_DELETE(m_infos);
}


void Repository::createImpl(Context &ctx)
{
	if(!hasAccess(ctx.dm().getCurrentUser())) {
		throw PermissionDeniedException(ctx.stack(), "No access to repository '%s'", m_name);
	}

	ProviderObjectDef &def = getDef(ctx);

	Plugin *plugin = def.getPlugin();
	if(plugin && !plugin->loadPlugin(ctx.dm())) {
		throw RuntimeError(ctx.stack(), "Unable to load plugin for repository type '%s'", m_type);
	}

	RepositoryImplFactory *factory = RepositoryImplRegistry::instance().getFactory(def);

	if(!factory) {
		throw RuntimeError(ctx.stack(), "Unrecognised repository type '%s'", m_type);
	}

	// Verify that all mandatory properties are present and warn of any we won't use
	def.verifyProperties(ctx, m_props);

	// Create an instance of the impl so that we may later execute it
	m_impl = factory->create(*this);
	if(!m_impl) {
		throw RuntimeError(ctx.stack(), "Unexpected error creating instance of repository type '%s'", m_type);
	}
}


Scope *Repository::getVars()
{
	if(!m_vars) {
		m_vars = new Scope(REPOSITORY_SCOPE, this);
		m_model.getVariablesForObject(*this, *m_vars);
	}

	return m_vars;
}


char *Repository::dirname(const char *filename)
{
	const char *ls = strrchr(filename, DIR_SEP_CHAR);
	if(!ls) {
		return NULL;
	}

	int len = ls - filename;

	char *ret = (char*) malloc(len + 1);
	strncpy(ret, filename, len);
	ret[len] = '\0';
	return ret;
}


void Repository::checkout(const char *dropzone, class ExtendedStmt &stmt, Context &ctx)
{
	if(!m_impl) {
		createImpl(ctx);
	}

	getDef(ctx).verifyArgs(ctx, stmt.getArgs(), m_props);

	m_impl->checkout(dropzone, stmt, ctx);

	// Debug - list of files checked out
	//if(m_files) {
	//	StringList *files = m_files->get(dropzone);
	//	if(files) {
	//		StringListIterator iter(*files);
	//		for(const char *f = iter.first(); f; f = iter.next()) {
	//			printf("\"%s\"\n", f);
	//		}
	//	}
	//}

	// Generate the dm.info files from the data we recorded from any callbacks
	generateDmInfos(dropzone);
}


void Repository::checked_out_file(const char *dropzone, const char *filename)
{
	if(!m_files) {
		m_files = new Hashtable<StringList>(false, true);
	}

	StringList *files = m_files->get(dropzone);
	if(!files) {
		files = new StringList();
		m_files->put(dropzone, files);
	}

	files->add(filename);
}


void Repository::checked_out_folder(const char *dropzone, const char *folder, const char *infoloc, bool fixed)
{
	if(!m_folders) {
		m_folders = new Hashtable<StringHashtable>(false, true);
	}
	if(!m_infos) {
		m_infos = new Hashtable<Hashtable<StringList> >(false, true);
	}

	StringHashtable *folders = m_folders->get(dropzone);
	if(!folders) {
		folders = new StringHashtable();
		m_folders->put(dropzone, folders);
	}
	Hashtable<StringList> *infos = m_infos->get(dropzone);
	if(!infos) {
		infos = new Hashtable<StringList>(false, true);
		m_infos->put(dropzone, infos);
	}

	// Repeatedly take dirname and register
	char *vpfn = strdup(folder);
	char *infn = strdup(infoloc);
	while(vpfn && infn && vpfn[0] && infn[0]) {
		if(folders->get(vpfn)) {
			// Existing folder - assume we have done the parents
			break;
		}

		// New folder - register it
		folders->put(vpfn, infn);

		// Record the infoloc in the reverse structure
		StringList *list = infos->get(infn);
		if(!list) {
			list = new StringList();
			infos->put(infn, list);
		}
		list->add(vpfn);
		
		// Get parent folder and go around again
		char *temp = m_impl->dirname(vpfn);
		SAFE_FREE(vpfn);
		vpfn = temp;
		if(!fixed) {
			temp = dirname(infn);
			SAFE_FREE(infn);
			infn = temp;
		}
	}
	SAFE_FREE(vpfn);
	SAFE_FREE(infn);
}


void DMAPI_API catFile(const char *filename)
{
	printf("file: %s\n----- 8< -----\n", filename);
	FILE *f = fopen(filename, "r");
	if(f) {
		char buf[1024];
		int n;
		while(n = fread(buf, 1, sizeof(buf)-1, f)) {
			buf[n] = '\0';
			printf("%s", buf);
		}
		fclose(f);
	}
	printf("----- 8< -----\n");
}


void Repository::generateDmInfos(const char *dropzone)
{
	if(!m_infos) {
		printf("DEBUG: No infos recorded for repository '%s'\n", m_name);
		return;
	}
	Hashtable<StringList> *infos = m_infos->get(dropzone);
	if(!infos) {
		printf("DEBUG: No infos recorded for dropzone '%s'\n", dropzone);
		return;
	}
	AutoPtr<StringList> keys = infos->keys();
	if(!keys) {
		printf("DEBUG: Failed to get keys for recorded infos for dropzone '%s'\n", dropzone);
		return;
	}
	StringListIterator kit(*keys);
	for(const char *info = kit.first(); info; info = kit.next()) {
		StringList *folders = infos->get(info);
		//printf("DEBUG: %s:\n", info);

		char *infofile = (char*) malloc(strlen(dropzone) + strlen(info) + 10);
		if((info[0] == '\\') || (info[0] == '/')) {
			if(info[1] == '\0') {
				// info is either / or \ - drop and just use platform separator
				sprintf(infofile, "%s%sdm.info", dropzone, DIR_SEP_STR);
			} else {
				sprintf(infofile, "%s%s%sdm.info", dropzone, info, DIR_SEP_STR);
			}
		} else {
			sprintf(infofile, "%s%s%s%sdm.info", dropzone, DIR_SEP_STR, info, DIR_SEP_STR);
		}

		struct stat sb;
		if(stat(infofile, &sb) != -1) {
			printf("DEBUG: %s already exists - we should be merging\n", infofile);
		}

		TiXmlDocument doc("dm.info");
		TiXmlElement *root = new TiXmlElement("files");
		int count = 0;

		StringListIterator fit(*folders);
		for(const char *folder = fit.first(); folder; folder = fit.next()) {
			char *comment = (char*) malloc(strlen(folder) + 12);
			sprintf(comment, " folder: %s ", folder);
			//printf("DEBUG:   <!--%s-->\n", comment);
			root->LinkEndChild(new TiXmlComment(comment));
			SAFE_FREE(comment);

			List<RepositoryTextPattern> *list = m_model.getTextPatternsForRepositoryPath(*this, folder);
			if(list) {
				ListIterator<RepositoryTextPattern> lit(*list);
				for(RepositoryTextPattern *rtp = lit.first(); rtp; rtp = lit.next()) {
					//printf("DEBUG:   <file name=\"%s\" text=\"%s\" />\n", rtp->pattern(), (rtp->text() ? "true" : "false"));
					TiXmlElement *file = new TiXmlElement("file");
					file->SetAttribute("name", rtp->pattern());
					file->SetAttribute("text", (rtp->text() ? "true" : "false"));
					root->LinkEndChild(file);
					count++;
				}
				SAFE_DELETE(list);
			}
		}

		doc.LinkEndChild(root);

		if(count > 0) {
			//doc.Print();
			doc.SaveFile(infofile);

			catFile(infofile);
		}

		SAFE_FREE(infofile);
	}
}


void Repository::print(int ind)
{
	indent(ind); printf("Repository: %s\n", m_name);
	printProviderObject(ind+1);
}


///////////////////////////////////////////////////////////////////////////////
// Notify
///////////////////////////////////////////////////////////////////////////////

Notify::Notify(class Model &model, int id, const char *name, const char *type)
	: ProviderObject(model, id, name, type), m_impl(NULL)
{}


Notify::~Notify()
{
	SAFE_DELETE(m_impl);
}


void Notify::createImpl(Context &ctx)
{
	if(!hasAccess(ctx.dm().getCurrentUser())) {
		throw PermissionDeniedException(ctx.stack(), "No access to notify '%s'", m_name);
	}

	ProviderObjectDef &def = getDef(ctx);

	Plugin *plugin = def.getPlugin();
	if(plugin && !plugin->loadPlugin(ctx.dm())) {
		throw RuntimeError(ctx.stack(), "Unable to load pluging for notify type '%s'", m_type);
	}

	NotifyProviderImplFactory *factory = NotifyProviderImplRegistry::instance().getFactory(def);

	if(!factory) {
		throw RuntimeError(ctx.stack(), "Unrecognised notify provider type '%s'", m_type);
	}

	// Verify that all mandatory properties are present and warn of any we won't use
	def.verifyProperties(ctx, m_props);

	// Create an instance of the impl so that we may later execute it
	m_impl = factory->create(*this);
	if(!m_impl) {
		throw RuntimeError(ctx.stack(), "Unexpected error creating instance of notify provider '%s'", m_type);
	}
}


class Scope *Notify::getVars()
{
	//if(!m_vars) {
	//	m_vars = new Scope(NOTIFY_SCOPE, this);
	//	m_model.getVariablesForObject(*this, *m_vars);
	//}

	//return m_vars;
	return NULL;
}


void Notify::notify(class ExtendedStmt &stmt, OutputStream &body, List<class AttachmentStmtImpl> *atts, class Context &ctx)
{
	if(!m_impl) {
		createImpl(ctx);
	}

	getDef(ctx).verifyArgs(ctx, stmt.getArgs(), m_props);

	m_impl->notify(stmt, body, atts, ctx);
}


void Notify::print(int ind)
{
	indent(ind); printf("Notify: %s\n", m_name);
	printProviderObject(ind+1);
}


///////////////////////////////////////////////////////////////////////////////
// Datasource
///////////////////////////////////////////////////////////////////////////////

Datasource::Datasource(class Model &model, int id, const char *name, const char *type)
	: ProviderObject(model, id, name, type), m_impl(NULL)
{}


Datasource::~Datasource()
{
	SAFE_DELETE(m_impl);
}


void Datasource::createImpl(Context &ctx)
{
	if(!hasAccess(ctx.dm().getCurrentUser())) {
		throw PermissionDeniedException(ctx.stack(), "No access to datasource '%s'", m_name);
	}

	ProviderObjectDef &def = getDef(ctx);

	Plugin *plugin = def.getPlugin();
	if(plugin && !plugin->loadPlugin(ctx.dm())) {
		throw RuntimeError(ctx.stack(), "Unable to load pluging for datasource type '%s'", m_type);
	}

	DatasourceProviderImplFactory *factory = DatasourceProviderImplRegistry::instance().getFactory(def);

	if(!factory) {
		throw RuntimeError(ctx.stack(), "Unrecognised datasource type '%s'", m_type);
	}

	// Verify that all mandatory properties are present and warn of any we won't use
	def.verifyProperties(ctx, m_props);

	// Create an instance of the impl so that we may later execute it
	m_impl = factory->create(*this);
	if(!m_impl) {
		throw RuntimeError(ctx.stack(), "Unexpected error creating instance of datasource '%s'", m_type);
	}
}


class Scope *Datasource::getVars()
{
	//if(!m_vars) {
	//	m_vars = new Scope(DATASOURCE_SCOPE, this);
	//	m_model.getVariablesForObject(*this, *m_vars);
	//}

	//return m_vars;
	return NULL;
}


void Datasource::query(ExtendedStmt &stmt, Context &ctx)
{
	if(!m_impl) {
		createImpl(ctx);
	}

	getDef(ctx).verifyArgs(ctx, stmt.getArgs(), m_props);

	m_impl->query(stmt, ctx);
}


void Datasource::print(int ind)
{
	indent(ind); printf("Datasource: %s\n", m_name);
	printProviderObject(ind+1);
}


///////////////////////////////////////////////////////////////////////////////
// Script
///////////////////////////////////////////////////////////////////////////////

Script::Script(Model &model, int repoid, const char *filepath)
	: m_model(model), m_repoid(repoid), m_filepath(DUP_NULL(filepath)),
	  m_action(NULL), m_textid(0), m_repo(NULL), m_parsed(false)
{}

Script::Script(Model &model, Action *action, int textid)
	: m_model(model), m_repoid(0), m_filepath(NULL), m_action(action),
	  m_textid(textid), m_repo(NULL), m_parsed(false)
{}


Script::~Script()
{
	SAFE_FREE(m_filepath);
	m_repo = NULL;				// Owned by cache
	m_action = NULL;			// Owned by cache
}


Repository *Script::getRepository()
{
	if(!m_repo) {
		m_model.getRepositoryForScript(*this);
	}
	return m_repo;
}


/*private*/ void Script::setRepository(Repository *repo)
{
	m_repo = repo;
}


int Script::parse(Context &ctx)
{
	if(m_parsed) {
		printf("DEBUG: Script '%s' has already been parsed\n", (m_action ? m_action->name() : m_filepath));
		return 1;
	}

	m_parsed = true;

	CharPtr filename;
	char *input = NULL;

	if(m_action) {
		// We are an action stored in the database
		if(!m_textid) {
			throw RuntimeError(ctx.stack(), "Text id for action '%s' missing.", m_action->name());
		}

		ConstCharPtr text = m_model.getActionText(m_textid);
		ConstCharPtr sig = m_action->getSignature();

		// Create an input buffer with the action name wrapped around the text
		// pulled from the db
		input = (char*) malloc(strlen(sig) + strlen(text) + 10);
		sprintf(input, "%s {\n%s\n}\n", (const char*) sig, (const char*) text);

		filename = strdup(sig);
	} else {
		// We are a script stored in a repository
		if(!m_repo) {
			getRepository();
		}
		if(!m_repo) {
			throw RuntimeError(ctx.stack(), "Repository for script '%s' not found.", (m_filepath ? m_filepath : "(null)"));
		}

		// Check to see if the dropzone was created in this session
		Dropzone *dz = ctx.dm().getDropzone("tdm_scripts");
		if(!dz) {
			// No, so create it, making sure it is empty
			dz = ctx.dm().newDropzone("tdm_scripts");
			if(!dz->create(true)) {
				// Set flag to prevent us trying to delete the non-empty folder when we exit
				putenv(strdup("trinounlink=Y"));
				throw RuntimeError(ctx.stack(), "Unable to create dropzone 'tdm_scripts'");
			}
		}
		const char *dropzone = dz->pathname();

		StmtList *args = new StmtList();
		args->add(new Stmt(strdup("pattern"), new Node(KIND_STR, strdup(m_filepath), true)));
		ExtendedStmt dummy(strdup("dummy"), args);
		m_repo->checkout(dropzone, dummy, ctx);

		Node nfilepath(NODE_STR, strdup(m_filepath), true);
		ExprPtr efilepath = nfilepath.evaluate(ctx);
		ConstCharPtr filepath = efilepath->stringify();

		filename = (char*) malloc(strlen(dropzone) + strlen((const char*) filepath) + 10);
		sprintf(filename, "%s%s%s", dropzone, DIR_SEP_STR, (const char*) filepath);

		//printf("DEBUG: parse '%s'...\n", filename);

		struct stat sb;
		if(stat(filename, &sb) != 0) {
			fprintf(stderr, "Input file '%s' not found\n", (const char*) filename);
			return 1;
		}

		int buflen = sb.st_size;
		input = (char*) malloc(buflen + 1);
		FILE *f = fopen(filename, "r");
		if(!f) {
			fprintf(stderr, "Error opening '%s'\n", (const char*) filename);
			return 1;
		}

		int read = fread(input, 1, buflen, f);
		fclose(f);

		if(read == 0) {
			return 1;
		}

		input[read] = '\0';
	}

	LexerBuffer lb(action_lexer, input, filename);

	yyparse_param param;
	param.buffer = &lb;

	int res = 1;
	try {
		res = yyparse(&param);
	} catch(...) {
		SAFE_FREE(input);
		throw;
	}

	SAFE_FREE(input);			// we have finished with the input buffer now

	if(res != 0) {
		SAFE_DELETE(param.actnlist);
		if(param.ex) {
			throw *((SyntaxError*) param.ex);
		}
		return 2;
	}

	if(!param.actnlist) {
		SAFE_DELETE(param.actnlist);
		return 3;
	}

	if(!getenv("trinosemantic")) {
		try {
			param.actnlist->semanticCheck(ctx.dm());
		} catch(...) {
			SAFE_DELETE(param.actnlist);
			throw;
		}
	}

	m_model.setActionNodes(param.actnlist);
	return 0;
}


void Script::print(int ind)
{
	//indent(ind); printf("Script: %s\n", m_name);
	//printObject(ind+1);
}


///////////////////////////////////////////////////////////////////////////////
// Field
///////////////////////////////////////////////////////////////////////////////

Field::Field(
		class Model &model, int id, const char *name,
		FIELD_KIND kind, const char *querystring
	)
	: m_model(model), m_id(id), m_name(DUP_NULL(name)), m_kind(kind),
	  m_querystring(DUP_NULL(querystring)), m_action(NULL)
{}


Field::~Field()
{
	SAFE_FREE(m_name);
	SAFE_FREE(m_querystring);
	m_action = NULL;	// Owned by cache
}


Action *Field::getAction()
{
	if(!m_action) {
		m_model.getActionForField(*this);
	}
	return m_action;
}


/*private*/ void Field::setAction(Action *action)
{
	m_action = action;
}


void Field::populate(DM &dm)
{
	switch(m_kind) {
	case FIELD_KIND_CHECKBOX: break;
	case FIELD_KIND_COMBO_ARRAY: {
		StringList *values = m_model.getFieldValuesForField(*this);
		if(values) {
			StringListIterator iter(*values);
			for(const char *s = iter.first(); s; s = iter.next()) {
				dm.writeToStdOut("%s", s);
			}
			SAFE_DELETE(values);
		} else {
			dm.writeToStdErr("Failed to get values for field '%s'", (m_name ? m_name : "(null)"));
		}
		}
		break;
	case FIELD_KIND_COMBO_DB: {
		StringList *values = m_model.getFieldValuesForField(m_querystring);
		if(values) {
			StringListIterator iter(*values);
			for(const char *s = iter.first(); s; s = iter.next()) {
				dm.writeToStdOut("%s", s);
			}
			SAFE_DELETE(values);
		} else {
			dm.writeToStdErr("Failed to get values for field '%s'", (m_name ? m_name : "(null)"));
		}
		}
		break;
	case FIELD_KIND_COMBO_ACTION: {
		if(!m_action) {
			getAction();
		}
		if(!m_action) {
			throw RuntimeError("Script for field '%s' not found.", (m_name ? m_name : "(null)"));
		}
		int res = dm.runAction(*m_action);
		}
		break;
	case FIELD_KIND_TEXT: break;
	}
}


///////////////////////////////////////////////////////////////////////////////
// ActionArg
///////////////////////////////////////////////////////////////////////////////

ActionArg::ActionArg(
		const char *name, int pos, bool reqd, bool pad, const char *sw
	)
	: m_name(DUP_NULL(name)), m_position(pos), m_required(reqd),
	  m_pad(pad), m_switch(DUP_NULL(sw))
{}


ActionArg::~ActionArg()
{
	SAFE_FREE(m_name);
	SAFE_FREE(m_switch);
}


///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////


Action::Action(
		Model &model, int id, ACTION_KIND kind, bool isFunction,
		bool resultIsExpr, const char *name, const char *filepath
	)
	: Object(model, id, name), m_actkind(kind), m_filepath(DUP_NULL(filepath)),
	  m_isFunction(isFunction), m_resultIsExpr(resultIsExpr), m_plugin(NULL),
	  m_args(NULL), m_argMap(NULL), m_parsed(false), m_script(NULL)
{}


Action::~Action()
{
	SAFE_FREE(m_filepath);
	m_plugin = NULL;	// Owned by cache
	SAFE_DELETE(m_argMap);
	SAFE_DELETE(m_args);
	m_script = NULL;	// Owned by cache
}


Hashtable<ActionArg> *Action::getArgMap()
{
	if(m_argMap) {
		return m_argMap;
	}

	m_model.getArgsForAction(*this);
	return m_argMap;
}


List<ActionArg> *Action::getArgs()
{
	if(m_args) {
		return m_args;
	}

	m_args = new List<ActionArg>(true);
	m_model.getArgsForAction(*this);
	return m_args;
}


void Action::add(ActionArg *arg)
{
	if(!m_args) {
		m_args = new List<ActionArg>(true);
	}
	if(!m_argMap) {
		m_argMap = new Hashtable<ActionArg>(false, false);
	}
	
	m_args->add(arg);
	m_argMap->put(arg->name(), arg);
}


char *Action::getSignature()
{
	char *ret;

	if(m_isFunction) {
		ret = (char*) malloc(strlen(m_name) + 12);
		sprintf(ret, "function %s(", m_name);

		if(!m_args) {
			getArgs();
		}

		ListIterator<ActionArg> iter(*m_args);
		bool first = true;
		for(ActionArg *aa = iter.first(); aa; aa = iter.next()) {
			ret = (char*) realloc(ret, strlen(ret) + strlen(aa->name()) + 3);
			if(!first) {
				strcat(ret, ",");
			}
			strcat(ret, aa->name());
			first = false;
		}

		strcat(ret, ")");
	} else {
		ret = (char*) malloc(strlen(m_name) + 8);
		sprintf(ret, "action %s", m_name);
	}

	return ret;
}


Script *Action::getScript()
{
	if(!m_script) {
		m_model.getScriptForAction(this);
	}
	return m_script;
}


void Action::setScript(Script *script)
{
	m_script = script;
}


Plugin *Action::getPlugin()
{
	if(!m_plugin) {
		m_model.getPluginForAction(*this);
	}
	return m_plugin;
}


void Action::setPlugin(Plugin *plugin)
{
	m_plugin = plugin;
}


int Action::parse(Context &ctx)
{
	switch(m_actkind) {
	case ACTION_KIND_SCRIPT:
	case ACTION_KIND_IN_DB:
		if(!m_parsed) {
			getScript();
			if(!m_script) {
				throw RuntimeError(ctx.stack(), "Failed to find script for action '%s'", m_name);
			}
			return m_script->parse(ctx);
		}
		break;
	case ACTION_KIND_EXTERNAL:
	case ACTION_KIND_PLUGIN:
		// Nothing to parse for external script or plugin
		return 0;
	default:
		throw RuntimeError(ctx.stack(), "Unrecognised action kind (%d)", m_actkind);
		break;
	}

	return 0;
}


class ActionNode *Action::getActionNode(Context &ctx)
{
	if(parse(ctx) != 0) {
		return NULL;
	}
	// TODO: Go to the script for the action, rather than the model
	ActionNode *ret = m_model.getActionNode(m_name);
	if(!ret) {
		throw RuntimeError(ctx.stack(), "Failed to find action '%s'", m_name);
	}
	return ret;
}


void Action::print(int indent)
{}


///////////////////////////////////////////////////////////////////////////////
// Plugin
///////////////////////////////////////////////////////////////////////////////

Plugin::Plugin(int id, int version, const char *library)
	: m_id(id), m_version(version), m_library(DUP_NULL(library)), m_loaded(false)
{}


Plugin::~Plugin()
{
	SAFE_FREE(m_library);
}


bool Plugin::loadPlugin(class DM &dm)
{
	if(!m_loaded) {
		m_loaded = dm.loadPlugin(m_library);
	}
	return m_loaded;
}


///////////////////////////////////////////////////////////////////////////////
// PluginObject
///////////////////////////////////////////////////////////////////////////////

PluginObject::PluginObject()
{}


/*virtual*/ PluginObject::~PluginObject()
{}


///////////////////////////////////////////////////////////////////////////////
// RepositoryTextPattern
///////////////////////////////////////////////////////////////////////////////

RepositoryTextPattern::RepositoryTextPattern(
		const char *path, const char *pattern, bool text
	)
	: m_path(DUP_NULL(path)), m_pattern(DUP_NULL(pattern)), m_text(text)
{}


RepositoryTextPattern::~RepositoryTextPattern()
{
	SAFE_FREE(m_path);
	SAFE_FREE(m_pattern);
}



///////////////////////////////////////////////////////////////////////////////
// Model
///////////////////////////////////////////////////////////////////////////////

Model::Model(class DMSql &sql)
	: m_sql(sql), m_envs(NULL), m_apps(NULL), m_scrCache(false, true),
	  m_pluginObjects(false, true), m_actionNodes(NULL), m_currentUser(NULL)
{}


Model::~Model()
{
	SAFE_DELETE(m_envs);		// not set as owner so will just delete list (envCache is owner)
	SAFE_DELETE(m_apps);		// not set as owner so will just delete list (appCache is owner)
	SAFE_DELETE(m_actionNodes);	// ActionList has a destructor
	m_currentUser = NULL;		// Owned by cache
}


List<Environment> *Model::internalGetEnvironments(const char *whereClause)
{
	if(!m_sql.executeQuery("select e.id, e.name, e.basedir "
			"from dm_environment e %s", whereClause)) {
		return NULL;
	}

	List<Environment> *ret = new List<Environment>();

	for(int i = 0; i < m_sql.rows(); i++) {
		int id = m_sql.getInt(i, 0);
		char *envName    = m_sql.getString(i, 1);
		char *envBasedir = m_sql.getString(i, 2);

		Environment *env = findOrCreateEnvironment(id, envName, envBasedir);
		ret->add(env);
	}

	return ret;
}


List<Domain> *Model::internalGetDomains(const char *fromClause, const char *whereClause)
{
	if(!m_sql.executeQuery("select d.id, d.name "
			"from %s dm_domain d %s ",
			fromClause, whereClause)) {
		return NULL;
	}

	List<Domain> *ret = new List<Domain>();

	for(int i = 0; i < m_sql.rows(); i++) {
		int id = m_sql.getInt(i, 0);
		char *domainName = m_sql.getString(i, 1);

		Domain *domain = findOrCreateDomain(id, domainName);
		ret->add(domain);
	}

	return ret;
}


List<Application> *Model::internalGetApplications(const char *whereClause)
{
	if(!m_sql.executeQuery("select a.id, a.name "
			"from dm_application a %s", whereClause)) {
		return NULL;
	}

	List<Application> *ret = new List<Application>(false);

	for(int i = 0; i < m_sql.rows(); i++) {
		int id = m_sql.getInt(i, 0);
		char *appName = m_sql.getString(i, 1);

		Application *app = findOrCreateApplication(id, appName);
		ret->add(app);
	}

	return ret;
}


List<User> *Model::internalGetUsers(const char *fromClause, const char *whereClause)
{
	if(!m_sql.executeQuery("select u.id, u.name, u.email, u.realname, u.phone "
			"from dm_user u %s %s ", fromClause, whereClause)) {
		return NULL;
	}

	List<User> *ret = new List<User>(false);

	for(int i = 0; i < m_sql.rows(); i++) {
		int id = m_sql.getInt(i, 0);
		char *userName  = m_sql.getString(i, 1);
		char *userEmail = m_sql.getString(i, 2, NULL);
		char *realName  = m_sql.getString(i, 3, NULL);
		char *userPhone = m_sql.getString(i, 4, NULL);

		User *user = findOrCreateUser(id, userName, userEmail, realName, userPhone);
		ret->add(user);
	}

	return ret;
}


Credentials *Model::internalGetCredentials(const char *fromClause, const char *whereClause)
{
	if(!m_sql.executeQuery("select c.id, c.name, c.kind, c.encusername, c.encpassword, c.filename "
			"from %s t, dm_credentials c where c.id = t.credid and %s ",
			fromClause, whereClause)) {
		return NULL;
	}

	if(m_sql.rows() > 0) {
		int id = m_sql.getInt(0, 0);
		char *name = m_sql.getString(0, 1, NULL);
		CREDENTIALS_KIND kind = (CREDENTIALS_KIND) m_sql.getInt(0, 2);
		char *encusername = m_sql.getString(0, 3, NULL);
		char *encpassword = m_sql.getString(0, 4, NULL);
		char *filename    = m_sql.getString(0, 5, NULL);

		return findOrCreateCredentials(id, name, kind, encusername, encpassword, filename);
	}

	return NULL;
}


Action *Model::internalGetAction(const char *fromClause, const char *whereClause)
{
	if(!m_sql.executeQuery(
			"select a.id, a.name, a.filepath, a.textid, "
			" a.repositoryid, a.function, a.resultisexpr, a.pluginid "
			"from dm_action a %s %s ", fromClause, whereClause)) {
		return NULL;
	}

	if(m_sql.rows() > 0) {
		int id = m_sql.getInt(0, 0);
		char *name = m_sql.getString(0, 1, NULL);
		char *filepath = m_sql.getString(0, 2, NULL);
		int textid = m_sql.getInt(0, 3);
		int repoid = m_sql.getInt(0, 4);
		bool isFunc = m_sql.getBool(0, 5);
		bool resIsExpr = m_sql.getBool(0, 6);
		int pluginid = m_sql.getInt(0, 7);

		ACTION_KIND kind;
		if(repoid) {
			kind = ACTION_KIND_SCRIPT;
		} else if(textid) {
			kind = ACTION_KIND_IN_DB;
		} else if(pluginid) {
			kind = ACTION_KIND_PLUGIN;
		} else {
			kind = ACTION_KIND_EXTERNAL;
		}

		return findOrCreateAction(id, kind, isFunc, resIsExpr, name, filepath);
	}

	return NULL;
}


List<Environment> *Model::getEnvironments()
{
	if(m_envs) {
		return m_envs;
	}

	const char *domains = m_currentUser ? m_currentUser->getAccessibleDomains() : NULL;
	if(domains) {
		char *whereClause = (char*) malloc(strlen(domains) + 25);
		sprintf(whereClause, "where e.domainid in (%s)", domains);
		m_envs = internalGetEnvironments(whereClause);
		SAFE_FREE(whereClause);
	} else {
		m_envs = internalGetEnvironments("");
	}
	return m_envs;
}


List<Application> *Model::getApplications()
{
	if(m_apps) {
		return m_apps;
	}

	const char *domains = m_currentUser ? m_currentUser->getAccessibleDomains() : NULL;
	if(domains) {
		char *whereClause = (char*) malloc(strlen(domains) + 25);
		sprintf(whereClause, "where a.domainid in (%s)", domains);
		m_apps = internalGetApplications(whereClause);
		SAFE_FREE(whereClause);
	} else {
		m_apps = internalGetApplications("");
	}
	return m_apps;
}


Environment *Model::getEnvironment(const char *name)
{
	// Have we already got this environment
	Environment *ret = m_envCache.get(name);
	if(ret) { return ret; }

	char *nameLit = m_sql.escapeLiteral(name);
	char whereClause[2100];
	sprintf(whereClause, "where e.name = %s", nameLit);
	m_sql.free(nameLit);

	AutoPtr<List<Environment> > matches = internalGetEnvironments(whereClause);
	if(matches && (matches->size() > 0)) {
		ListIterator<Environment> iter(*matches);
		ret = iter.first();
	}

	return ret;
}


Application *Model::getApplication(const char *name)
{
	// Have we already got this application
	Application *ret = m_appCache.get(name);
	if(ret) { return ret; }

	char *nameLit = m_sql.escapeLiteral(name);
	char whereClause[2100];
	sprintf(whereClause, "where a.name = %s", nameLit);
	m_sql.free(nameLit);

	AutoPtr<List<Application> > matches = internalGetApplications(whereClause);
	if(matches && (matches->size() > 0)) {
		ListIterator<Application> iter(*matches);
		ret = iter.first();
	}

	return ret;
}


User *Model::getUser(const char *name)
{
	// Have we already got this user
	User *ret = m_usrCache.get(name);
	if(ret) { return ret; }

	char *nameLit = m_sql.escapeLiteral(name);
	char whereClause[1024];
	sprintf(whereClause, "where u.name = %s", nameLit);
	m_sql.free(nameLit);

	AutoPtr<List<User> > matches = internalGetUsers("", whereClause);
	if(matches && (matches->size() > 0)) {
		ListIterator<User> iter(*matches);
		ret = iter.first();
	}

	return ret;
}


Repository *Model::getRepository(const char *name)
{
	// Have we already got this repository
	Repository *ret = m_repCache.get(name);
	if(ret) { return ret; }

	char *nameLit = m_sql.escapeLiteral(name);
	char whereClause[1024];
	sprintf(whereClause, "where t.name = %s", nameLit);
	m_sql.free(nameLit);

	AutoPtr<List<Repository> > matches = internalGetProviderObjects<Repository>(m_repCache, "", whereClause);
	if(matches && (matches->size() > 0)) {
		ListIterator<Repository> iter(*matches);
		ret = iter.first();
	}

	return ret;
}


Notify *Model::getNotifier(const char *name)
{
	// Have we already got this notifier
	Notify *ret = m_nfyCache.get(name);
	if(ret) { return ret; }

	char *nameLit = m_sql.escapeLiteral(name);
	char whereClause[1024];
	sprintf(whereClause, "where t.name = %s", nameLit);
	m_sql.free(nameLit);

	AutoPtr<List<Notify> > matches = internalGetProviderObjects<Notify>(m_nfyCache, "", whereClause);
	if(matches && (matches->size() > 0)) {
		ListIterator<Notify> iter(*matches);
		ret = iter.first();
	}

	return ret;
}


Datasource *Model::getDatasource(const char *name)
{
	// Have we already got this datasource
	Datasource *ret = m_datCache.get(name);
	if(ret) { return ret; }

	char *nameLit = m_sql.escapeLiteral(name);
	char whereClause[1024];
	sprintf(whereClause, "where t.name = %s", nameLit);
	m_sql.free(nameLit);

	AutoPtr<List<Datasource> > matches = internalGetProviderObjects<Datasource>(m_datCache, "", whereClause);
	if(matches && (matches->size() > 0)) {
		ListIterator<Datasource> iter(*matches);
		ret = iter.first();
	}

	return ret;
}


Field *Model::getField(const char *name)
{
	// Have we already got this field
	Field *ret = m_fldCache.get(name);
	if(ret) { return ret; }

	char *nameLit = m_sql.escapeLiteral(name);

	if(!m_sql.executeQuery("select f.id, f.name, f.type, f.querystring "
			"from dm_field f where f.name = %s ", nameLit)) {
		m_sql.free(nameLit);
		return NULL;
	}

	m_sql.free(nameLit);

	if(m_sql.rows() < 1) {
		return NULL;
	}

	int id = m_sql.getInt(0, 0);
	char *fldName  = m_sql.getString(0, 1);
	FIELD_KIND fldKind = (FIELD_KIND) m_sql.getInt(0, 2);
	char *fldQueryString = m_sql.getString(0, 3, NULL);

	ret = new Field(*this, id, fldName, fldKind, fldQueryString);
	m_fldCache.put(ret);

	return ret;
}


StringList *Model::getFieldValuesForField(Field &field)
{
	if(!m_sql.executeQuery("select fv.fieldvalue "
			"from dm_fieldvalues fv where fv.fieldid = %d "
			"order by fv.positionid ", field.id())) {
		return NULL;
	}

	StringList *ret = new StringList();

	for(int i = 0; i < m_sql.rows(); i++) {
		char *fldValue = m_sql.getString(i, 0);
		ret->add(fldValue);
	}

	return ret;
}


StringList *Model::getFieldValuesForField(const char *querystring)
{
	if(!m_sql.executeQuery(querystring)) {
		return NULL;
	}

	StringList *ret = new StringList();

	for(int i = 0; i < m_sql.rows(); i++) {
		char *fldValue = m_sql.getString(i, 0);
		ret->add(fldValue);
	}

	return ret;
}


void Model::getRepositoryForScript(Script &script)
{
	char whereClause[1024];
	sprintf(whereClause, "where t.id = %d", script.repoid());

	AutoPtr<List<Repository> > matches =
		internalGetProviderObjects<Repository>(m_repCache, "", whereClause);
	if(matches && (matches->size() > 0)) {
		ListIterator<Repository> iter(*matches);
		script.setRepository(iter.first());
	}
}


Action *Model::getAction(const char *name)
{
	Action *ret = m_actCache.get(name);
	if(ret) {
		return ret;
	}

	char *nameLit = m_sql.escapeLiteral(name);

	char whereClause[1024];
	sprintf(whereClause, "where a.name = %s", nameLit);
	ret = internalGetAction("", whereClause);
	m_sql.free(nameLit);
	return ret;
}


void Model::getArgsForAction(Action &action)
{
	if(!m_sql.executeQuery(
			"select aa.name, aa.position, aa.required, aa.pad, aa.switch "
			"from dm_actionarg aa "
			"where aa.actionid = %d order by aa.position ", action.id())) {
		return;
	}

	for(int i = 0; i < m_sql.rows(); i++) {
		char *argName   = m_sql.getString(i, 0);
		int argPos      = m_sql.getInt(i, 1);
		bool argReqd    = m_sql.getBool(i, 2);
		bool argPad     = m_sql.getBool(i, 3);
		char *argSwitch = m_sql.getString(i, 4, NULL);
		action.add(new ActionArg(argName, argPos, argReqd, argPad, argSwitch));
	}	
}


void Model::getScriptForAction(Action *action)
{
	if(!m_sql.executeQuery("select a.name, a.filepath, a.textid, a.repositoryid "
			"from dm_action a where a.id = %d ", action->id())) {
		return;
	}

	if(m_sql.rows() > 0) {
		char *name = m_sql.getString(0, 0, NULL);
		char *filepath = m_sql.getString(0, 1, NULL);
		int textid = m_sql.getInt(0, 2);
		int repoid = m_sql.getInt(0, 3);

		switch(action->actionKind()) {
		case ACTION_KIND_SCRIPT: {
			Script *script = findOrCreateScript(repoid, filepath);
			action->setScript(script);
			}
			break;
		case ACTION_KIND_IN_DB: {
			Script *script = findOrCreateScript(action, textid);
			action->setScript(script);
			}
			break;
		}
	}
}


char *Model::getActionText(int textid)
{
	if(!m_sql.executeQuery(
		"select at.data from dm_actiontext at where at.id = %d ", textid)) {
		return NULL;
	}

	if(m_sql.rows() > 0) {
		char *text = m_sql.getString(0, 0, NULL);
		char *ret = DUP_NULL(text);
		m_sql.clear();					// Clear down immediately
		return ret;
	}

	return NULL;
}


void Model::getPluginForAction(Action &act)
{
	if(!m_sql.executeQuery(
		"select p.id, p.version, p.library from dm_action a, dm_plugin p "
		"where p.id = a.pluginid and a.id = %d ", act.id())) {
		return;
	}

	if(m_sql.rows() > 0) {
		int id = m_sql.getInt(0, 0);
		int version = m_sql.getInt(0, 1);
		char *library = m_sql.getString(0, 2, NULL);
		Plugin *plugin = findOrCreatePlugin(id, version, library);
		act.setPlugin(plugin);
	}
}


/*private*/ void Model::setCurrentUser(User *user)
{
	m_currentUser = user;
}


User *Model::getCurrentUser()
{
	return m_currentUser;
}


void Model::updateUserLastLogin(User &user)
{
	m_sql.executeCommand("update dm_user "
		"set lastlogin = now() "
		"where id = %d ", user.id());
}


/**
 * Validate the given user's password hash.  To avoid sending the actual hash
 * value across the wire, we query for a match against the hash that we have
 * calculated from the supplied password.  Whilst this might expose how we hash
 * the passwords, it means sniffing the wire whilst attempting a login does not
 * give away the actual password hash, only the hash of what has been entered.
 */
bool Model::validateHashedPassword(User &user, const char *passhash)
{
	char *passhashLit = m_sql.escapeLiteral(passhash);

	if(!m_sql.executeQuery(
			"select u.id from dm_user u "
			"where u.id = %d and u.passhash = %s ",
			user.id(), passhashLit)) {
		m_sql.free(passhashLit);
		return false;
	}

	m_sql.free(passhashLit);

	if(m_sql.rows() > 0)
    {
		int id = m_sql.getInt(0, 0);
		return (id == user.id());
	}

	return false;
}


char *Model::getAccessibleDomains(int domainid)
{
	if(!m_sql.executeQuery(
			"select d.id from dm_domain d where d.domainid =  %d ",
			domainid)) {
		return NULL;
	}

	char *ret = NULL;
	int rows = m_sql.rows();

	if(rows > 0) {
		int *domains = (int*) malloc(rows * sizeof(int));

		int i;

		// Cache the result so that we can start another query
		for(i = 0; i < rows; i++) {
			domains[i] = m_sql.getInt(i, 0);
			//printf("DEBUG: domain %d\n", domains[i]);
		}

		// Now recurse using the cached results
		for(i = 0; i < rows; i++) {
			char *list = getAccessibleDomains(domains[i]);

			char idstr[32];
			sprintf(idstr, "%d", domains[i]);

			if(ret) {
				ret = (char*) realloc(ret, strlen(idstr) + strlen(ret) + (list ? strlen(list) : 0) + 3);
				strcat(ret, ",");
			} else {
				ret = (char*) malloc(strlen(idstr) + (list ? strlen(list) : 0) + 2);
				*ret = '\0';
			}

			strcat(ret, idstr);

			if(list) {
				strcat(ret, ",");
				strcat(ret, list);
				SAFE_FREE(list);
			}

			//printf("DEBUG: ret %s\n", ret);
		}

		SAFE_FREE(domains);
	}

	return ret;
}


char *Model::getAccessibleDomains(Domain &domain)
{
	char idstr[32];
	sprintf(idstr, "%d", domain.id());

	char *ret = strdup(idstr);

	char *list = getAccessibleDomains(domain.id());

	if(list) {
		ret = (char*) realloc(ret, strlen(ret) + strlen(list) + 2);
		strcat(ret, ",");
		strcat(ret, list);
		SAFE_FREE(list);
	}

	return ret;
}


Environment *Model::findOrCreateEnvironment(
	int id, const char* name, const char *basedir)
{
	Environment *env = NULL;
	if(!(env = m_envCache.get(id))) {
		env = new Environment(*this, id, name, basedir);
		m_envCache.put(env);
	}
	return env;
}


Domain *Model::findOrCreateDomain(int id, const char* name)
{
	Domain *domain = NULL;
	if(!(domain = m_domCache.get(id))) {
		domain = new Domain(*this, id, name);
		m_domCache.put(domain);
	}
	return domain;
}


Server *Model::findOrCreateServer(
	int id, const char *name, const char *hostname, const char *protocol,
	const char *basedir, const char *hosttype, LINE_END_FORMAT lineends)
{
	Server *server = NULL;
	if(!(server = m_srvCache.get(id))) {
		server = new Server(
			*this, id, name, hostname, protocol, basedir, hosttype, lineends);
		m_srvCache.put(server);
	}
	return server;
}


Application *Model::findOrCreateApplication(int id, const char *name)
{
	Application *app = NULL;
	if(!(app = m_appCache.get(id))) {
		app = new Application(*this, id, name);
		m_appCache.put(app);
	}
	return app;
}


User *Model::findOrCreateUser(
	int id, const char *name, const char* email,
	const char *realname, const char *phone)
{
	User *user = NULL;
	if(name || email) {
		if(!(user = m_usrCache.get(id))) {
			user = new User(*this, id, name, email, realname, phone);
			m_usrCache.put(user);
		}
	}
	return user;
}


UserGroup *Model::findOrCreateUserGroup(
	int id, const char *name, const char* email)
{
	UserGroup *group = NULL;
	if(name || email) {
		if(!(group = m_usgCache.get(id))) {
			group = new UserGroup(*this, id, name, email);
			m_usgCache.put(group);
		}
	}
	return group;
}


ProviderObjectDef *Model::findOrCreateProviderObjectDef(
	int id, const char *name, const char *kind, Plugin *plugin)
{
	ProviderObjectDef *pod = NULL;
	if(!(pod = m_podCache.get(id))) {
		pod = new ProviderObjectDef(id, name, kind, plugin);
		m_podCache.put(pod);
		getPropertyDefsForProviderObjectDef(*pod);
	}
	return pod;
}


Credentials *Model::findOrCreateCredentials(
	int id, const char *name, CREDENTIALS_KIND kind,
	char *encuser, const char *encpass, const char *filename)
{
	Credentials *cred = NULL;
	if(!(cred = m_crdCache.get(id))) {
		switch(kind) {
		case CREDENTIALS_USE_DIALOG:
		case CREDENTIALS_ENCRYPTED:
			// These should never be set in database
			throw RuntimeError("Credentials kind not allowed in database");
		case CREDENTIALS_IN_DATABASE:
		case CREDENTIALS_FROM_VARS:
			cred = new Credentials(id, name, kind, encuser, encpass);
			break;
		case CREDENTIALS_RTI3_DFO_IN_FILESYSTEM:
		case CREDENTIALS_HARVEST_DFO_IN_FILESYSTEM:
			return new Credentials(id, name, kind, filename);
		default:
			throw RuntimeError("Unrecognised credentials kind in database (%d)", (int) kind);
		}
		m_crdCache.put(cred);
	}
	return cred;
}


Action *Model::findOrCreateAction(
	int id, ACTION_KIND kind, bool isFunc, bool resIsExpr,
	const char *name, const char *filepath)
{
	Action *action = NULL;
	if(!(action = m_actCache.get(id))) {
		action = new Action(
			*this, id, kind, isFunc, resIsExpr, name, filepath);
		m_actCache.put(action);
	}
	return action;
}


Script *Model::findOrCreateScript(int repoid, const char *filepath)
{
	char *key = (char*) malloc(strlen(filepath) + 32);
	sprintf(key, "%d:%s", repoid, filepath);

	Script *script = NULL;
	if(!(script = m_scrCache.get(key))) {
		script = new Script(*this, repoid, filepath);
		m_scrCache.put(key, script);
	}

	SAFE_FREE(key);
	return script;
}


Script *Model::findOrCreateScript(Action *action, int textid)
{
	// TODO: consider whether action name needs to be part of key
	char key[32];
	sprintf(key, "%d", textid);

	Script *script = NULL;
	if(!(script = m_scrCache.get(key))) {
		script = new Script(*this, action, textid);
		m_scrCache.put(key, script);
	}

	return script;
}


Plugin *Model::findOrCreatePlugin(int id, int version, const char *library)
{
	Plugin *plugin = NULL;
	if(!(plugin = m_plgCache.get(id))) {
		plugin = new Plugin(id, version, library);
		m_plgCache.put(plugin);
	}
	return plugin;
}


void Model::getServersForEnvironment(Environment &env)
{
	if(!m_sql.executeQuery(
			"select s.id, s.name, s.hostname, s.protocol, s.basedir, st.name, st.lineends "
			"from (dm_server s left join dm_servertype st on s.typeid = st.id), "
			" dm_serversinenv sie "
			"where sie.envid = %d and s.id = sie.serverid" , env.id())) {
		return;
	}

	for(int i = 0; i < m_sql.rows(); i++)
    {
		int id = m_sql.getInt(i, 0);
		char *serverName     = m_sql.getString(i, 1);
		char *serverHostname = m_sql.getString(i, 2, NULL);
		char *serverProtocol = m_sql.getString(i, 3, NULL);
		char *serverBasedir  = m_sql.getString(i, 4, NULL);
		char *serverHosttype = m_sql.getString(i, 5, NULL);
		LINE_END_FORMAT lineends = (LINE_END_FORMAT) m_sql.getInt(i, 6);

		Server *srv = findOrCreateServer(
			id, serverName, serverHostname, serverProtocol,
			serverBasedir, serverHosttype, lineends);
		env.add(srv);
	}
}


void Model::getApplicationsForEnvironment(Environment &env)
{
	if(!m_sql.executeQuery("select a.id, a.name "
			"from dm_application a, "
			"dm_appsinenv aie where aie.envid = %d "
			"and a.id = aie.appid" , env.id())) {
		return;
	}

	for(int i = 0; i < m_sql.rows(); i++) {
		int id = m_sql.getInt(i, 0);
		char *appName = m_sql.getString(i, 1);

		Application *app = findOrCreateApplication(id, appName);
		env.add(app);
	}
}


void Model::getCredentialsForEnvironment(Environment &env)
{
	char whereClause[256];
	sprintf(whereClause, "t.id = %d", env.id());

	Credentials *creds = internalGetCredentials("dm_environment", whereClause);
	env.setCredentials(creds);
}


void Model::getSubdomainsForDomain(Domain *domain)
{
	char whereClause[256];
	sprintf(whereClause, "where d.domainid = %d", domain->id());

	AutoPtr<List<Domain> > matches = internalGetDomains("", whereClause);

	if(matches) {
		ListIterator<Domain> iter(*matches);
		for(Domain *child = iter.first(); child; child = iter.next()) {
			child->setDomain(domain);
			domain->add(child);
		}
	}
}


void Model::getEnvironmentsForDomain(Domain *domain)
{
	char whereClause[256];
	sprintf(whereClause, "where e.domainid = %d ", domain->id());
	AutoPtr<List<Environment> > matches = internalGetEnvironments(whereClause);

	if(matches) {
		ListIterator<Environment> iter(*matches);
		for(Environment *e = iter.first(); e; e = iter.next()) {
			e->setDomain((Domain*) domain);
			domain->add(e);
		}
	}
}


void Model::getApplicationsForDomain(Domain *domain)
{
	char whereClause[256];
	sprintf(whereClause, "where a.domainid = %d", domain->id());

	AutoPtr<List<Application> > matches = internalGetApplications(whereClause);

	if(matches) {
		ListIterator<Application> iter(*matches);
		for(Application *child = iter.first(); child; child = iter.next()) {
			child->setDomain(domain);
			domain->add(child);
		}
	}
}


void Model::getRepositoriesForDomain(Domain *domain)
{
	getProviderObjectsForDomain<Repository>(m_repCache, domain);
}


void Model::getNotifysForDomain(Domain *domain)
{
	getProviderObjectsForDomain<Notify>(m_nfyCache, domain);
}


void Model::getDatasourcesForDomain(Domain *domain)
{
	getProviderObjectsForDomain<Datasource>(m_datCache, domain);
}


void Model::getParentForDomain(Domain &domain)
{
	char whereClause[256];
	sprintf(whereClause, "where egc.id = %d and eg.id = egc.domainid", domain.id());

	AutoPtr<List<Domain> > matches = internalGetDomains(
		"dm_domain egc, (dm_domain eg left join dm_user u on eg.ownerid = u.id"
		"left join dm_usergroup g on eg.ogrpid = g.id)", whereClause);

	if(matches && (matches->size() > 0)) {
		ListIterator<Domain> iter(*matches);
		domain.setDomain(iter.first());
		// Note that we don't add an incomplete list of children
		// they will be read from the db only if requested
	}
}


void Model::getCredentialsForServer(Server &server)
{
	char whereClause[256];
	sprintf(whereClause, "t.id = %d", server.id());

	Credentials *creds = internalGetCredentials(server.table(), whereClause);
	server.setCredentials(creds);
}


void Model::getActionForApplication(Application &app)
{
	char whereClause[1024];
	sprintf(whereClause, "where app.id = %d and a.id = app.actionid", app.id());

	Action *action = internalGetAction(", dm_application app", whereClause);
	app.setAction(action);
}


void Model::getUsersForUserGroup(UserGroup &group)
{
	char whereClause[1024];
	sprintf(whereClause, "where u.id = uig.userid and uig.groupid = %d", group.id());

	AutoPtr<List<User> > matches = internalGetUsers(", dm_usersingroup uig", whereClause);

	if(matches) {
		ListIterator<User> iter(*matches);
		for(User *user = iter.first(); user; user = iter.next()) {
			group.add(user);
		}
	}
}


void Model::getUserGroupsForUser(User &user)
{
	if(!m_sql.executeQuery("select g.id, g.name, g.email "
			"from dm_usergroup g, dm_usersingroup uig "
			"where g.id = uig.groupid and uig.userid = %d", user.id())) {
		return;
	}

	for(int i = 0; i < m_sql.rows(); i++) {
		int id = m_sql.getInt(i, 0);
		char *groupName  = m_sql.getString(i, 1);
		char *groupEmail = m_sql.getString(i, 2, NULL);

		UserGroup *group = findOrCreateUserGroup(id, groupName, groupEmail);
		user.add(group);
	}
}


void Model::setActionNodes(class ActionNodeList *actions)
{
	if(m_actionNodes) {
		m_actionNodes->merge(*actions);
		SAFE_DELETE(actions);
	} else {
		m_actionNodes = actions;
	}
}


class ActionNode *Model::firstActionNode()
{
	return m_actionNodes ? m_actionNodes->firstActionNode() : NULL;
}


class ActionNode *Model::getActionNode(const char *name)
{
	return m_actionNodes ? m_actionNodes->getActionNode(name) : NULL;
}


void Model::getOwnerForObject(Object &obj)
{
	if(!m_sql.executeQuery(
			"select o.ownerid, o.ogrpid, u.name, u.email, "
			" u.realname, u.phone, g.name, g.email "
			"from (%s o left join dm_user u on o.ownerid = u.id "
			"left join dm_usergroup g on o.ogrpid = g.id) "
			"where o.id = %d ", obj.table(), obj.id())) {
		return;
	}

	if(m_sql.rows() > 0) {
		int ownerid          = m_sql.getInt(0, 0);
		int ogrpid           = m_sql.getInt(0, 1);
		char *userName       = m_sql.getString(0, 2, NULL);
		char *userEmail      = m_sql.getString(0, 3, NULL);
		char *userReal       = m_sql.getString(0, 4, NULL);
		char *userPhone      = m_sql.getString(0, 5, NULL);
		char *groupName      = m_sql.getString(0, 6, NULL);
		char *groupEmail     = m_sql.getString(0, 7, NULL);

		User *owner = findOrCreateUser(ownerid, userName, userEmail, userReal, userPhone);
		UserGroup *owngrp = findOrCreateUserGroup(ogrpid, groupName, groupEmail);

		if(owner) {
			obj.setOwner(owner);
		} else if(owngrp) {
			obj.setOwner(owngrp);
		}
	}
}


void Model::getVariablesForObject(Object &obj, Scope &vars)
{
	if(!m_sql.executeQuery("select v.name, v.value, v.arrayid, v.nocase "
			"from %svars v where v.%s = %d ",
			obj.table(), obj.fk(), obj.id())) {
		return;
	}

	int deferred_arrayid[10];
	DMArray *deferred_array[10];
	int deferred_arrays = 0;

	for(int i = 0; i < m_sql.rows(); i++) {
		char *varName  = m_sql.getString(i, 0);
		char *varValue = m_sql.getString(i, 1, NULL);
		int arrayid    = m_sql.getInt(i, 2);
		bool nocase    = m_sql.getBool(i, 3);

		if(arrayid > 0) {
			// Create the new array, but defer the filling till later
			DMArray *ht = vars.newArray(varName, nocase);
			deferred_arrayid[deferred_arrays] = arrayid;
			deferred_array[deferred_arrays] = ht;
			deferred_arrays++;
		} else {
			vars.set(varName, varValue, nocase);
		}
	}

	// Now run queries for each array after we have finished with the variables query
	for(int a = 0; a < deferred_arrays; a++) {
		if(m_sql.executeQuery("select a.name, a.value "
				"from dm_arrayvalues a where a.id = %d ",
				deferred_arrayid[a])) {
			for(int i = 0; i < m_sql.rows(); i++) {
				char *arrName  = m_sql.getString(i, 0);
				char *arrValue = m_sql.getString(i, 1, NULL);
				deferred_array[a]->put(arrName, new Variable(NULL, arrValue));
			}
		}
	}
}


void Model::getAccessForObject(Object &obj)
{
	if(!m_sql.executeQuery("select a.usrgrpid, a.deployaccess, g.name, g.email "
			"from %saccess a, dm_usergroup g where a.%s = %d and g.id = a.usrgrpid ",
			obj.table(), obj.fk(), obj.id())) {
		return;
	}

	for(int i = 0; i < m_sql.rows(); i++) {
		int usrgrpid   = m_sql.getInt(i, 0);
		bool access    = m_sql.getBool(i, 1);
		char *grpName  = m_sql.getString(i, 2);
		char *grpEmail = m_sql.getString(i, 3, NULL);

		UserGroup *usrgrp = findOrCreateUserGroup(usrgrpid, grpName, grpEmail);
		obj.add(usrgrp);
	}
}

		
void Model::getDomainForObject(Object &obj)
{
	char fromClause[256], whereClause[256];
	sprintf(fromClause, "%s t,", obj.table());
	sprintf(whereClause, "where t.id = %d and d.id = t.domainid", obj.id());
	AutoPtr<List<Domain> > matches = internalGetDomains(fromClause, whereClause);
	if(matches && (matches->size() > 0)) {
		ListIterator<Domain> iter(*matches);
		obj.setDomain(iter.first());
		// Note that we don't add an incomplete list of children
		// they will be read from the db only if requested
	}
}


void Model::getSummaryForObject(Object &obj)
{
	if(!m_sql.executeQuery("select t.summary "
			"from %s t where t.id = %d ",
			obj.table(), obj.id())) {
		return;
	}

	if(m_sql.rows() > 0) {
		char *summary  = m_sql.getString(0, 0, NULL);
		obj.setSummary(summary ? summary : "");
	}
}


void Model::getNotesForObject(Object &obj)
{
	if(!m_sql.executeQuery("select t.notes "
			"from %s t where t.id = %d ",
			obj.table(), obj.id())) {
		return;
	}

	if(m_sql.rows() > 0) {
		char *notes  = m_sql.getString(0, 0, NULL);
		obj.setNotes(notes ? notes : "");
	}
}


void Model::getCredentialsForProviderObject(ProviderObject &po)
{
	char whereClause[256];
	sprintf(whereClause, "t.id = %d", po.id());

	Credentials *creds = internalGetCredentials(po.table(), whereClause);
	po.setCredentials(creds);
}


void Model::getPropertiesForProviderObject(ProviderObject &obj)
{
	if(!m_sql.executeQuery("select p.name, p.value, p.encrypted "
			"from %sprops p where p.%s = %d ",
			obj.table(), obj.fk(), obj.id())) {
		return;
	}

	for(int i = 0; i < m_sql.rows(); i++) {
		char *propName  = m_sql.getString(i, 0);
		char *propValue = m_sql.getString(i, 1, NULL);
		bool  propEnc =   m_sql.getBool(i, 2);
		obj.setProperty(new Property(propName, propValue, propEnc));
	}
}


ProviderObjectDef *Model::getDefForProviderObject(ProviderObject &obj)
{
	if(!m_sql.executeQuery("select d.id, d.name, d.pluginid, p.version, p.library "
			"from %s o, (dm_providerdef d left join dm_plugin p on p.id = d.pluginid) "
			"where o.id = %d and d.id = o.defid ",
			obj.table(), obj.id())) {
		return NULL;
	}

	if(m_sql.rows() > 0) {
		int id = m_sql.getInt(0, 0);
		char *defName  = m_sql.getString(0, 1);
		int pluginId = m_sql.getInt(0, 2);
		int pluginVer = m_sql.getInt(0, 3);
		char *pluginLib = m_sql.getString(0, 4, NULL);
		Plugin *plugin = NULL;
		if(pluginId) {
			plugin = findOrCreatePlugin(pluginId, pluginVer, pluginLib);
		}
		return findOrCreateProviderObjectDef(id, defName, obj.def_kind(), plugin);
	}

	printf("DEBUG: No def with for %s with id %d found - have you set it up correctly?\n", obj.def_kind(), obj.id());
	return NULL;
}


void Model::getPropertyDefsForProviderObjectDef(ProviderObjectDef &pod)
{
	if(!m_sql.executeQuery("select pd.name, pd.required, pd.appendable "
			"from dm_propertydef pd where pd.defid = %d ", pod.id())) {
		return;
	}

	for(int i = 0; i < m_sql.rows(); i++) {
		char *pdName  = m_sql.getString(i, 0);
		bool  pdReqd = m_sql.getBool(i, 1);
		bool  pdApnd = m_sql.getBool(i, 2);
		pod.add(new PropertyDef(pdName, pdReqd, false, pdApnd));
	}
}


List<RepositoryTextPattern> *Model::getTextPatternsForRepositoryPath(
		Repository &repo, const char *path)
{
	if(!m_sql.executeQuery("select rtp.path, rtp.pattern, rtp.istext "
			"from dm_repositorytextpattern rtp "
			"where rtp.repositoryid = %d and rtp.path = '%s' ", repo.id(), path)) {
		return NULL;
	}

	List<RepositoryTextPattern> *ret = new List<RepositoryTextPattern>(true);
	for(int i = 0; i < m_sql.rows(); i++) {
		char *rtpPath    = m_sql.getString(i, 0);
		char *rtpPattern = m_sql.getString(i, 1);
		bool  rtpText    = m_sql.getBool(i, 2);
		ret->add(new RepositoryTextPattern(rtpPath, rtpPattern, rtpText));
	}

	return ret;
}


void Model::getActionForField(Field &field)
{
	char whereClause[1024];
	sprintf(whereClause, "where f.id = %d and a.id = f.actionid", field.id());

	Action *action = internalGetAction(", dm_field f", whereClause);
	field.setAction(action);
}


void Model::setPluginObject(const char *name, PluginObject *obj)
{
	m_pluginObjects.put(name, obj);
}


PluginObject *Model::getPluginObject(const char *name)
{
	return m_pluginObjects.get(name);
}
